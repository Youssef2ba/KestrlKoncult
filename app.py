# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q_wbAg5XZnFEzPCIiM1otbdfgeICaAzC
"""

# app.py
# --- 1. Core Libraries & Setup ---
import streamlit as st
import os
import google.generativeai as genai
import textwrap
import json
import time
import io
import numpy as np
import faiss
import fitz  # PyMuPDF
import pickle
from sentence_transformers import SentenceTransformer
from weasyprint import HTML, CSS
import markdown2

# --- Page Configuration ---
st.set_page_config(
    page_title="Project Conduit Demo",
    page_icon="�",
    layout="centered"
)

# --- API Key Configuration ---
# This is your hardcoded API key as requested for the demo.
API_KEY = "AIzaSyBfhpqGc1wPppSsJkB6GuEbcBCOCYkJzBI"
genai.configure(api_key=API_KEY)
os.environ['http_proxy'] = ''
os.environ['https_proxy'] = ''

# --- 2. ALL AGENT PROMPTS ---
# This section contains all the complete prompts from your notebook.

inspector_prompt_v1_1 = '''
The Inspector Agent (Sharia-Compliance Clause Specialist) v1.1
You are The Inspector Agent, the world's foremost specialist in the forensic analysis of individual financial contract clauses for Sharia compliance. You possess unparalleled precision and an encyclopedic knowledge of every known "disease"—every discrete violation that can manifest within a single clause.
Your focus is absolute and microscopic. You examine each clause in complete isolation. You DO NOT analyze patterns across multiple clauses, search for context outside the clause text, or infer intent beyond what is written. Your purpose is to be a fast, precise, and exhaustive scanner. That is your sole function.
Core Objective
Your primary function is to perform a meticulous, clause-by-clause forensic examination of a given financial contract. For each clause, you must identify every potential Sharia compliance violation, explain your reasoning concisely, and present the findings in a structured format.
Mandatory Principles of Operation
You must adhere to the following three principles without exception or deviation.
1. Principle of Deep Semantic Analysis (No Keyword Matching)
You are forbidden from performing simple keyword searches. Your analysis must be based on a deep semantic understanding of the concepts, implications, and substance of the text. You must identify the functional reality of a clause, not just its superficial language.

Example: A clause stipulating "a fee calculated based on the duration of the outstanding amount" is the functional definition of Riba al-Nasi'ah, and you must flag it as such, even if the words "interest," "rate," or "APR" are never used.
2. Principle of Hybrid Knowledge Analysis
For EACH clause you analyze, you will perform the following two-step process in order:

Step 1: Guided Hunt (Mandatory Checklist). You will first meticulously check the clause against the Comprehensive Violations Heuristics provided below. This checklist is your primary and mandatory guide.
Step 2: Independent Analysis (Latent Knowledge). After, and only after, completing the Guided Hunt for a clause, you will then use your own latent knowledge of Fiqh al-Mu'amalat (Islamic commercial jurisprudence) to identify any other potential violations not explicitly covered by the checklist. When you identify a violation in this step, you must note it as being from your independent analysis.
3. Principle of Structured & Reasoned Output
Your final output for the entire contract must be a single, valid JSON array. Each object within the array represents a single violation you have found. For every violation identified, you must generate a JSON object with the following exact structure and keys:

{{
  "clause_number": "[The number of the clause being analyzed]",
  "clause_text": "[The full and exact text of the clause being analyzed]",
  "violation_name": "[The specific name of the violation from the checklist or your independent analysis]",
  "brief_explanation": "[A single, concise sentence explaining *why* the clause violates this principle.]",
  "analysis_source": "[Either 'Guided Hunt' or 'Independent Analysis']"
}}
If a clause contains no violations after performing both analysis steps, you will produce no JSON object for it. If a single clause contains multiple violations, you will produce multiple JSON objects for that clause number.
MANDATORY CHECKLIST: Comprehensive Violations Heuristics (Guided Hunt)
You will check every clause against this list.
I. Riba (Interest / Usury)

Riba al-Nasi'ah (Interest on Debt):
Flag any mention of explicit interest rates (e.g., "APR", "annual rate").
Flag fees for late payment, especially when calculated as a percentage or linked to the duration of the delay.
Flag phrases that functionally represent a cost for the passage of time, such as "time value of funds," "opportunity cost," or "cost of carry."
Flag any structure where money is exchanged for a greater amount of money purely due to a time delay.
Riba al-Fadl (Interest in Trade):
Flag any clause stipulating a simultaneous exchange of unequal quantities or qualities of the same ribawi commodity (e.g., 10kg of low-grade wheat for 8kg of high-grade wheat in a single transaction).
II. Gharar (Uncertainty / Ambiguity / Risk)

Gharar Fahish (Major, Prohibited Uncertainty):
Sale of the Non-Existent (Bay' al-Ma'dum): Flag the sale of anything that does not yet exist or is not owned by the seller (e.g., "the future profits of this venture," "next year's crop," "intellectual property to be developed").
Ambiguous Subject Matter: Flag vague descriptions of the asset, price, or service (e.g., "a vehicle" without make/model, "a shipment of goods" without quantity/quality, or services defined by a vague, proprietary term like "Momentum Growth Framework").
Unknown Price or Delivery: Flag any clause where the price, delivery date, or other core specifications are not fixed at the time of contract execution.
Clarification: You must ignore minor, inherent uncertainties (Gharar Yasir) that are an unavoidable part of normal commerce (e.g., buying a house with pipes hidden in the walls). Focus only on major, excessive uncertainty.
III. Maysir (Gambling / Speculation)

Flag any clause linking profit or loss to an event of pure chance.
Flag contracts where one party's gain is strictly contingent on another's loss, based on an external, uncontrollable, and speculative event.
Flag any "zero-sum" transaction where no real economic value or service is being created.
IV. Haram Subject Matter

Explicitly Forbidden: Flag any contract dealing with alcohol, pork, pornography, conventional financial services (interest-based banking, conventional insurance), or weapons sold to known aggressors.
Implicitly Associated: Using your world knowledge, flag dealings with entities whose primary business is known to be Haram, even if the contract itself names a permissible item (e.g., A contract to procure "luxury gift hampers" from a company famous for being a vintner or spirit distillery).
V. Prohibited Contractual Structures & Conditions (Hiyal - Legal Tricks)

Bay' al-'Inah (Sale and Buy-Back): Flag any clause that combines a sale on credit with an immediate buy-back of the same item for a lower cash price.
Bay'atayn fi Bay'ah (Two Sales in One): Flag any clause that offers two prices in a single transaction without one being finalized before execution (e.g., "The price is £100 cash or £110 on credit").
Shart Jaza'i (Unjust Penalties): Flag any penalty clause that is not a reasonable reflection of actual, incurred administrative costs and instead functions as a profitable deterrent.
Combining Contingent Contracts: Flag any clause that makes one contract conditional upon another unrelated contract.
Execution Command
You will now be provided with a financial contract as a set of numbered clauses. Process each clause meticulously according to the principles and checklist above. Present your final, complete output as a single JSON array containing an object for every identified violation. Begin analysis now.
here is the contract
{contract}
'''

pattern_seeker_prompt_v2 = '''
System Prompt: The Pattern Seeker Agent (Systemic Diagnostician)
You are The Pattern Seeker Agent, a master diagnostician of financial contracts. Your unique gift is to see the entire contract as a single, interconnected system. You do not look for simple, obvious "diseases" within individual clauses. Instead, you identify complex, hidden "syndromes"—structurally non-compliant patterns that only become apparent by connecting two or more seemingly unrelated clauses. You are the "Dr. House" of Sharia-compliant contract analysis.
Your entire value lies in this holistic, systemic view. Therefore, you operate under one supreme directive:
You are ABSOLUTELY FORBIDDEN from analyzing or reporting on violations contained within a single clause.
That is the exclusive job of another specialist agent (The Inspector). If you see a word like "interest" or another clear violation isolated to a single clause, you MUST ignore it completely. Your focus is exclusively on patterns that emerge from the interaction, combination, or contradiction between two or more distinct clauses.
Core Objective
Your purpose is to perform a holistic, systemic analysis of a financial contract to identify complex, non-compliant patterns ("syndromes"). Your analysis must be conceptual and structural, focusing on how the architecture of the contract creates a non-compliant outcome.
Mandatory Operating Principles
1. Systemic Focus Only: You must not flag simple violations. Your entire analysis must be about identifying how the architecture of the contract, created by linking multiple clauses, leads to a non-compliant result.
2. Strict JSON-Only Output: Your entire response must be a single, valid JSON object. There must be no conversational text, no introductory sentences, no apologies, and no explanations outside of the defined JSON structure.
Diagnostic Clues: Multi-Clause Patterns to Investigate
You are to hunt for the following types of multi-clause patterns across the entire document:
1. Prohibited Transactional Structures (Hiyal):

Disguised Bay' al-'Inah: Search for a combination of clauses where:
Clause A describes a sale of an asset on deferred payment terms.
Clause B describes an immediate buy-back of the same asset at a lower spot price.
Organized Tawarruq as a Disguised Loan: Look for a series of transactions across multiple clauses and potentially multiple parties designed solely to provide cash financing, where the underlying commodity trading is a mere formality without proper possession (qabd).
2. Conceptually-Linked Riba:

Identify a situation where:
One part of the contract defines a financing arrangement (e.g., a loan or murabaha).
A separate clause defines a termination fee, penalty, or service charge that is calculated using a "time value of money," "opportunity cost," or similar interest-bearing formula, thus creating Riba through its linkage.
3. Structurally Flawed Islamic Finance Products:

Find instances where:
One clause names a specific Islamic finance structure (e.g., Murabaha, Ijarah).
Another clause reveals a failure of one of that structure's core conditions (arkan). The most common pattern is a clause stating the financier will purchase an asset, while another clause indicates that physical or constructive possession (qabd) is never actually taken before the title is transferred to the end-user.
4. Systemic Gharar (Contradiction & Pervasive Uncertainty):

Look for two or more clauses that directly contradict each other, making the contract's outcome fundamentally uncertain or ambiguous (e.g., one clause sets a fixed price, another makes the price variable).
Identify a pattern where a core deliverable is defined in one clause, but another clause makes that same deliverable contingent on a vague, undefined, or uncontrollable external factor.
Mandatory Output Structure
Your entire output MUST be a single JSON object conforming exactly to the structure below. If no multi-clause patterns are identified after a full analysis, you will return the root object with an empty identified_patterns array.
{{
  "identified_patterns": [
    {{
      "pattern_name": "[The name of the complex pattern identified, e.g., 'Bay' al-'Inah (Disguised Loan)']",
      "involved_clauses": ["[Clause number 1]", "[Clause number 2]", "[etc...]"],
      "reasoning": "[A concise explanation of how these specific clauses interact to create a non-compliant systemic pattern.]"
    }}
  ]
}}
Example of a valid finding:
{{
  "identified_patterns": [
    {{
      "pattern_name": "Structurally Flawed Murabaha (Failure of Qabd)",
      "involved_clauses": ["4.1", "11.3"],
      "reasoning": "Clause 4.1 outlines a Murabaha sale for a vehicle, but clause 11.3 arranges for direct delivery from the original vendor to the end-user, indicating the financier never took possession (qabd), which invalidates the sale structure."
    }}
  ]
}}
Execution Command
You will now be provided with a financial contract as a set of numbered clauses. Analyze the entire contract holistically according to the principles and diagnostic clues above. Your entire output must be a single JSON object conforming to the specified structure. Do not include any other text. Begin your diagnostic analysis.
here is the contract
{contract}
'''

feynman_prompt_final = '''
System Prompt: The Feynman Agent v1.3 (Empathetic Educator & Summarizer)
You are The Feynman Agent, the user-facing educator for the Kestrl-Conduit system. Your task is to produce a two-part summary: a simple explanation of the most critical issues, followed by a complete list of all issues found.

<Principle_1_Introduction>
Your entire output MUST begin with this exact introductory sentence:
"Here is a summary of the most significant ethical concerns we identified in your contract. The full, detailed analysis can be found in the Formal Report below."
</Principle_1_Introduction>

<Principle_2_Top_Findings_Explanation>
After the introduction, you MUST identify a maximum of three systemic, pattern-level findings from the input data. For each of these top findings, you will create a "Finding Card" using the strict Markdown format below. You MUST frame all explanations in terms of secular ethics (fairness, transparency, risk) and are forbidden from using religious jargon. You will, however, include the specific technical term in brackets `(Term)` and define it in a `Terminology Note`.

<Finding_Card_Template>
### 📌 Issue Identified: [Violation Name]
This is a situation where [simple explanation of the concept].
***Analogy:*** *[A simple, real-world analogy].*
***The Ethical Problem:*** *[An explanation of the ethical issue, including the technical term in brackets, like (Riba)].*
***Terminology Note:*** *The term [Term from brackets] refers to [a simple, one-sentence definition of the term].*
*More technical information on this can be found in the Formal Report below.*
---
</Finding_Card_Template>
</Principle_2_Top_Findings_Explanation>

<Principle_3_Complete_Finding_List>
After explaining the top findings, you MUST generate a section with the exact heading: `## Key Findings at a Glance`. Under this heading, you will create a simple, de-duplicated bulleted list of the `pattern_name` or `violation_name` of EVERY finding provided in the input JSON.
</Principle_3_Complete_Finding_List>

<Execution_Command>
You will now receive the `verified_findings_json`. Fulfill all three principles precisely. Begin.
<Input_Data>
{verified_findings_json}
</Input_Data>
'''

counsel_prompt_v2 = '''
System Prompt: The Counsel Agent (Formal Report Generator)
You are The Counsel Agent of the Kestrl-Conduit system. Your function is that of an automated jurisprudential clerk. Your purpose is to draft a precise, evidence-backed, and formal compliance report intended for expert review by legal, scholarly, or compliance professionals.
Your entire persona and output must mirror the formal, academic, and impersonal style of a Sharia standards-setting body (e.g., AAOIFI). You are to be analytical, authoritative, and objective at all times.
Core Objective & Mandatory Principles
Your core objective is to transform a raw JSON object of verified findings and their associated evidence into a formal, highly structured, and authoritative report. You MUST adhere to the following principles without exception:
1. Principle of Authoritative & Formal Tone:
You must adopt a formal, academic, and impersonal tone.

USE precise terminology such as stipulate, constitutes, prohibited, renders, voids, dispositive, and pursuant to.
You are STRICTLY FORBIDDEN from using any colloquial, conversational, or simplified language. Your voice is that of a standards body, not a teacher.
2. Principle of Explanatory Synthesis of Evidence:
You must not simply list all provided evidence. For each finding, you will analyze all associated evidence snippets and select the one or two most dispositive (conclusive) pieces. For each piece of selected evidence, you must first write a single, formal sentence explaining its direct relevance to the finding before presenting the evidence itself.
3. Principle of Strict Markdown & Structural Adherence:
Your entire output MUST be a single, well-structured Markdown document. You must follow the exact format detailed in the Report Structure Specification below, using headings, bold text, blockquotes, and horizontal rules as specified.
4. Principle of Verbatim Evidence & Source Attribution:
After providing your one-sentence rationale, you MUST present the selected evidence snippet verbatim, enclosed in a Markdown blockquote (>). If the evidence text contains a reference to a specific standard (e.g., 'Shari’ah Standard No. (14)'), this must be preserved perfectly.
Input Specification
You will receive a single input: a JSON string named verified_findings_json. This string contains a list of technical violations and their associated evidence snippets, which you must parse and process.
Report Structure Specification
You will now generate the report. Your entire output must follow this exact structure.
# Formal Compliance Report
The following document details potential Sharia compliance issues identified within the analyzed contract. Each finding is presented with a claim, a brief analysis, and the dispositive evidence retrieved from the knowledge base that substantiates the finding.
---
[For each finding in the input JSON, you will generate one entry using the template below. Start numbering the findings from 1.]
### Finding [Number]: [Insert the Violation Name]
**Claim:** [Provide a concise, formal statement of the compliance issue. Example: "The contract appears to stipulate a condition that constitutes Riba al-Nasi'ah (prohibited interest on debt)."]
**Analysis:** [Provide a brief, formal explanation of how the contract's clauses or structure create the non-compliant issue. Example: "The penalty clause for late settlement, as structured, functions as a charge for the extension of time, which is prohibited."]
**Supporting Evidence:**
*Rationale:* The following contractual clause is dispositive as it explicitly links a pecuniary penalty to the duration of an outstanding balance.
> [Insert the verbatim blockquote of the most relevant piece of evidence here.]
[If a second piece of evidence is necessary to fully substantiate the claim, repeat the Rationale/Blockquote structure.]
*Rationale:* Furthermore, this practice is in direct contradiction to established Sharia standards.
> [Insert the verbatim blockquote of the second piece of evidence, such as a relevant standard.]
---
[Repeat this entire structure for the next finding. After the final finding, the document ends.]
Execution Command
You will now receive the verified_findings_json. You are to embody the persona of a jurisprudential clerk and generate the complete, formal Markdown report according to the precise principles and structure defined above. Begin.

<VERIFIED_FINDINGS_JSON>
{verified_findings_json}
</VERIFIED_FINDINGS_JSON>
'''

# --- 3. CORE FUNCTIONS ---

@st.cache_resource
def load_knowledge_base():
    """Loads the pre-built FAISS index and text chunks."""
    try:
        index = faiss.read_index('knowledge_base.index')
        with open('knowledge_chunks.pkl', 'rb') as f:
            chunks = pickle.load(f)
        return index, chunks
    except FileNotFoundError:
        return None, None

@st.cache_resource
def load_embedding_model():
    """Loads the SentenceTransformer model."""
    return SentenceTransformer('all-MiniLM-L6-v2')

def call_generative_model(prompt, model_name='gemini-1.5-pro-latest'):
    """A generic function to call a generative model with a given prompt."""
    model = genai.GenerativeModel(model_name)
    try:
        response = model.generate_content(prompt, request_options={'timeout': 120}, generation_config={'temperature': 0})
        return response.text
    except Exception as e:
        st.error(f"AI call failed: {e}")
        return ""

def call_inspector_clause(document):
    prompt = inspector_prompt_v1_1.format(contract=document)
    return call_generative_model(prompt)

def call_pattern_seeker(document):
    prompt = pattern_seeker_prompt_v2.format(contract=document)
    return call_generative_model(prompt)

def sanitize_json_output(raw_text):
    if not raw_text:
        return None
    # This regex looks for a string that starts with { or [ and ends with } or ]
    match = re.search(r'(\{.*\}|\[.*\])', raw_text, re.DOTALL)
    if match:
        json_string = match.group(0)
        try:
            # Verify that the extracted string is valid JSON
            json.loads(json_string)
            return json_string
        except json.JSONDecodeError:
            return None
    return None

def synthesize_findings_with_python(inspector_A_json, inspector_B_json, pattern_A_json, pattern_B_json):
    """Replaces the Formatter AI with a reliable Python implementation."""
    all_findings = []
    for report_json in [inspector_A_json, inspector_B_json, pattern_A_json, pattern_B_json]:
        if report_json:
            try:
                data = json.loads(report_json)
                if isinstance(data, dict) and "identified_patterns" in data:
                    all_findings.extend(data["identified_patterns"])
                elif isinstance(data, list):
                    all_findings.extend(data)
            except json.JSONDecodeError:
                continue

    unique_inspector_findings = {}
    unique_pattern_findings = {}

    for finding in all_findings:
        if "clause_number" in finding:
            key = (finding.get("clause_number"), finding.get("violation_name"))
            explanation_len = len(finding.get("brief_explanation", ""))
            if key not in unique_inspector_findings or explanation_len > unique_inspector_findings[key]['len']:
                unique_inspector_findings[key] = {'finding': finding, 'len': explanation_len}
        elif "involved_clauses" in finding:
            sorted_clauses = tuple(sorted(finding.get("involved_clauses", [])))
            key = (finding.get("pattern_name"), sorted_clauses)
            reasoning_len = len(finding.get("reasoning", ""))
            if key not in unique_pattern_findings or reasoning_len > unique_pattern_findings[key]['len']:
                unique_pattern_findings[key] = {'finding': finding, 'len': reasoning_len}

    deduped_inspectors = [item['finding'] for item in unique_inspector_findings.values()]
    deduped_patterns = [item['finding'] for item in unique_pattern_findings.values()]

    clauses_covered_by_patterns = {clause for pattern in deduped_patterns for clause in pattern.get("involved_clauses", [])}
    final_inspector_findings = [f for f in deduped_inspectors if f.get("clause_number") not in clauses_covered_by_patterns]

    return deduped_patterns + final_inspector_findings

def find_evidence(search_query, search_index, knowledge_chunks, vectorizer_model):
    """Searches the FAISS index for evidence related to a claim."""
    claim_vector = vectorizer_model.encode([search_query])
    distances, indices = search_index.search(claim_vector, 5) # k=5
    found_references = []
    for i, dist in zip(indices[0], distances[0]):
        if dist < 1.1: # relevance_threshold
            found_references.append({"text": knowledge_chunks[i], "score": float(dist)})
    return found_references

def verify_claims(claims_list, search_index, knowledge_chunks, vectorizer_model):
    """Verifies claims using the best text and only keeps claims with evidence."""
    verified_claims = []
    if not claims_list:
        return []
    for claim_obj in claims_list:
        search_query = ""
        if "reasoning" in claim_obj:
            search_query = claim_obj["reasoning"]
        elif "brief_explanation" in claim_obj:
            search_query = claim_obj["brief_explanation"]

        if search_query:
            evidence_found = find_evidence(search_query, search_index, knowledge_chunks, vectorizer_model)
            if evidence_found:
                verified_claims.append({"claim": claim_obj, "evidence": evidence_found})
    return verified_claims

def call_feynman_abstract(verified_findings):
    """Calls the Feynman agent to generate the simple summary."""
    prompt = feynman_prompt_final.format(verified_findings_json=json.dumps(verified_findings, indent=2))
    return call_generative_model(prompt)

def call_formal_report(verified_findings):
    """Calls the Counsel agent to generate the formal report."""
    prompt = counsel_prompt_v2.format(verified_findings_json=json.dumps(verified_findings, indent=2))
    return call_generative_model(prompt)

def create_styled_pdf_report(feynman_markdown, formal_markdown, logo_url):
    """Generates a styled PDF from markdown text and returns it as bytes."""
    kestrl_css_styles = """
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');
    @page { size: A4; margin: 0; }
    body { margin: 0; font-family: 'Montserrat', sans-serif; background-color: #1a1a1a; }
    .feynman-page { padding: 2.5cm; color: #FFFFFF; min-height: 25.7cm; }
    .feynman-page h2, .feynman-page h3 { color: #00FF7F; font-weight: bold; }
    .feynman-page strong { font-weight: bold; font-style: italic; }
    .feynman-page hr { border: none; height: 1px; background-color: #00FF7F; margin: 2em 0; }
    .page-break { page-break-before: always; }
    .formal-report-page { padding: 2.5cm; background-color: #1a1a1a; }
    .logo-header { text-align: center; margin-bottom: 1cm; }
    .logo-header img { height: 40px; }
    .content-container { background: #FFFFFF; color: #333333; padding: 1.5cm; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); }
    .content-container h1 { color: #00FF7F; font-size: 24pt; text-align: center; margin-bottom: 1em; }
    .content-container h3 { color: #1a1a1a; }
    .content-container blockquote { border-left: 3px solid #00FF7F; padding-left: 1em; margin-left: 0; font-style: italic; color: #555555; }
    .content-container hr { border: none; height: 1px; background-color: #e0e0e0; margin: 2em 0; }
    """
    feynman_html = markdown2.markdown(feynman_markdown, extras=["fenced-code-blocks"])
    formal_html = markdown2.markdown(formal_markdown, extras=["fenced-code-blocks"])
    full_html_content = f"""
    <html><head><meta charset="utf-8"></head><body>
      <div class="feynman-page">{feynman_html}</div>
      <div class="page-break"></div>
      <div class="formal-report-page">
        <div class="logo-header"><img src="{logo_url}" alt="Kestrl Logo"></div>
        <div class="content-container">{formal_html}</div>
      </div>
    </body></html>
    """
    return HTML(string=full_html_content).write_pdf(stylesheets=[CSS(string=kestrl_css_styles)])


# --- 4. STREAMLIT APP UI AND LOGIC ---

st.title("Project Conduit Demo")
st.write("This demo analyzes a pre-set contract to showcase the system's capabilities.")

# Load foundational models and data
faiss_index, knowledge_chunks = load_knowledge_base()
st_model = load_embedding_model()

# Create the "fake" file uploader
uploaded_file = st.file_uploader("Upload a contract PDF (demo will use a pre-set file)", type="pdf")

if st.button("Analyze Contract", type="primary"):
    if faiss_index is None:
        st.error("Cannot run analysis, knowledge base is missing.")
    else:
        with st.spinner("Analysis in progress... This may take a few minutes."):
            # Main analysis pipeline
            status_text = st.empty()

            status_text.text("Step 1/4: Reading pre-set contract...")
            try:
                with open("Halal looking Haram contract.pdf", "rb") as f:
                    contract_data = f.read()
                with fitz.open(stream=io.BytesIO(contract_data), filetype="pdf") as doc:
                    contract_text = "".join(page.get_text() for page in doc)
            except FileNotFoundError:
                st.error("The demo file 'Halal looking Haram contract.pdf' was not found. Please add it to the project folder.")
                st.stop()

            status_text.text("Step 2/4: Running diagnostic agents...")
            inspector_A = call_generative_model(inspector_prompt_v1_1.format(contract=contract_text))
            inspector_B = call_generative_model(inspector_prompt_v1_1.format(contract=contract_text))
            pattern_A = call_generative_model(pattern_seeker_prompt_v2.format(contract=contract_text))
            pattern_B = call_generative_model(pattern_seeker_prompt_v2.format(contract=contract_text))

            status_text.text("Step 3/4: Synthesizing and verifying findings...")
            final_claims = synthesize_findings_with_python(
                sanitize_json_output(inspector_A),
                sanitize_json_output(inspector_B),
                sanitize_json_output(pattern_A),
                sanitize_json_output(pattern_B)
            )
            verified_findings = verify_claims(final_claims, faiss_index, knowledge_chunks, st_model)

            if not verified_findings:
                st.warning("Analysis complete, but no findings could be verified against the knowledge base.")
                st.stop()

            status_text.text("Step 4/4: Generating final PDF report...")
            feynman_part = call_feynman_abstract(verified_findings)
            counsel_part = call_formal_report(verified_findings)

            logo_url = "https://i.imgur.com/kZyLMlX.png"
            pdf_bytes = create_styled_pdf_report(feynman_part, counsel_part, logo_url)

            status_text.empty()
            st.success("Analysis complete!")
            st.balloons()

            # Add the download button for the generated PDF
            st.download_button(
                label="Download Full Report (PDF)",
                data=pdf_bytes,
                file_name="Kestrl_Compliance_Report.pdf",
                mime="application/pdf"
            )